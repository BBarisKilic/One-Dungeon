// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'start_game_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StartGameState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StartGameStateCopyWith<$Res> {
  factory $StartGameStateCopyWith(
          StartGameState value, $Res Function(StartGameState) then) =
      _$StartGameStateCopyWithImpl<$Res, StartGameState>;
}

/// @nodoc
class _$StartGameStateCopyWithImpl<$Res, $Val extends StartGameState>
    implements $StartGameStateCopyWith<$Res> {
  _$StartGameStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StartGameState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$MenuImplCopyWith<$Res> {
  factory _$$MenuImplCopyWith(
          _$MenuImpl value, $Res Function(_$MenuImpl) then) =
      __$$MenuImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MenuImplCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$MenuImpl>
    implements _$$MenuImplCopyWith<$Res> {
  __$$MenuImplCopyWithImpl(_$MenuImpl _value, $Res Function(_$MenuImpl) _then)
      : super(_value, _then);

  /// Create a copy of StartGameState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$MenuImpl with DiagnosticableTreeMixin implements _Menu {
  const _$MenuImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.menu()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.menu'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MenuImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return menu();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return menu?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (menu != null) {
      return menu();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return menu(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return menu?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (menu != null) {
      return menu(this);
    }
    return orElse();
  }
}

abstract class _Menu implements StartGameState {
  const factory _Menu() = _$MenuImpl;
}

/// @nodoc
abstract class _$$PlayImplCopyWith<$Res> {
  factory _$$PlayImplCopyWith(
          _$PlayImpl value, $Res Function(_$PlayImpl) then) =
      __$$PlayImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlayImplCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$PlayImpl>
    implements _$$PlayImplCopyWith<$Res> {
  __$$PlayImplCopyWithImpl(_$PlayImpl _value, $Res Function(_$PlayImpl) _then)
      : super(_value, _then);

  /// Create a copy of StartGameState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PlayImpl with DiagnosticableTreeMixin implements _Play {
  const _$PlayImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.play()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.play'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PlayImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return play();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return play?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (play != null) {
      return play();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return play(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return play?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (play != null) {
      return play(this);
    }
    return orElse();
  }
}

abstract class _Play implements StartGameState {
  const factory _Play() = _$PlayImpl;
}

/// @nodoc
abstract class _$$SoundImplCopyWith<$Res> {
  factory _$$SoundImplCopyWith(
          _$SoundImpl value, $Res Function(_$SoundImpl) then) =
      __$$SoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SoundImplCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$SoundImpl>
    implements _$$SoundImplCopyWith<$Res> {
  __$$SoundImplCopyWithImpl(
      _$SoundImpl _value, $Res Function(_$SoundImpl) _then)
      : super(_value, _then);

  /// Create a copy of StartGameState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SoundImpl with DiagnosticableTreeMixin implements _Sound {
  const _$SoundImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.sound()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.sound'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return sound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return sound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (sound != null) {
      return sound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return sound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return sound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (sound != null) {
      return sound(this);
    }
    return orElse();
  }
}

abstract class _Sound implements StartGameState {
  const factory _Sound() = _$SoundImpl;
}

/// @nodoc
abstract class _$$LanguageImplCopyWith<$Res> {
  factory _$$LanguageImplCopyWith(
          _$LanguageImpl value, $Res Function(_$LanguageImpl) then) =
      __$$LanguageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LanguageImplCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$LanguageImpl>
    implements _$$LanguageImplCopyWith<$Res> {
  __$$LanguageImplCopyWithImpl(
      _$LanguageImpl _value, $Res Function(_$LanguageImpl) _then)
      : super(_value, _then);

  /// Create a copy of StartGameState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LanguageImpl with DiagnosticableTreeMixin implements _Language {
  const _$LanguageImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.language()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.language'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LanguageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return language();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return language?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (language != null) {
      return language();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return language(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return language?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (language != null) {
      return language(this);
    }
    return orElse();
  }
}

abstract class _Language implements StartGameState {
  const factory _Language() = _$LanguageImpl;
}

/// @nodoc
abstract class _$$HowToPlayImplCopyWith<$Res> {
  factory _$$HowToPlayImplCopyWith(
          _$HowToPlayImpl value, $Res Function(_$HowToPlayImpl) then) =
      __$$HowToPlayImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HowToPlayImplCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$HowToPlayImpl>
    implements _$$HowToPlayImplCopyWith<$Res> {
  __$$HowToPlayImplCopyWithImpl(
      _$HowToPlayImpl _value, $Res Function(_$HowToPlayImpl) _then)
      : super(_value, _then);

  /// Create a copy of StartGameState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$HowToPlayImpl with DiagnosticableTreeMixin implements _HowToPlay {
  const _$HowToPlayImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.howToPlay()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.howToPlay'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HowToPlayImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return howToPlay();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return howToPlay?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (howToPlay != null) {
      return howToPlay();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return howToPlay(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return howToPlay?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (howToPlay != null) {
      return howToPlay(this);
    }
    return orElse();
  }
}

abstract class _HowToPlay implements StartGameState {
  const factory _HowToPlay() = _$HowToPlayImpl;
}

/// @nodoc
abstract class _$$AboutImplCopyWith<$Res> {
  factory _$$AboutImplCopyWith(
          _$AboutImpl value, $Res Function(_$AboutImpl) then) =
      __$$AboutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AboutImplCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$AboutImpl>
    implements _$$AboutImplCopyWith<$Res> {
  __$$AboutImplCopyWithImpl(
      _$AboutImpl _value, $Res Function(_$AboutImpl) _then)
      : super(_value, _then);

  /// Create a copy of StartGameState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AboutImpl with DiagnosticableTreeMixin implements _About {
  const _$AboutImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.about()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.about'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AboutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return about();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return about?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (about != null) {
      return about();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return about(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return about?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (about != null) {
      return about(this);
    }
    return orElse();
  }
}

abstract class _About implements StartGameState {
  const factory _About() = _$AboutImpl;
}
