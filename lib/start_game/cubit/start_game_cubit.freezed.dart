// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'start_game_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$StartGameState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StartGameStateCopyWith<$Res> {
  factory $StartGameStateCopyWith(
          StartGameState value, $Res Function(StartGameState) then) =
      _$StartGameStateCopyWithImpl<$Res, StartGameState>;
}

/// @nodoc
class _$StartGameStateCopyWithImpl<$Res, $Val extends StartGameState>
    implements $StartGameStateCopyWith<$Res> {
  _$StartGameStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_MenuCopyWith<$Res> {
  factory _$$_MenuCopyWith(_$_Menu value, $Res Function(_$_Menu) then) =
      __$$_MenuCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MenuCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$_Menu>
    implements _$$_MenuCopyWith<$Res> {
  __$$_MenuCopyWithImpl(_$_Menu _value, $Res Function(_$_Menu) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Menu with DiagnosticableTreeMixin implements _Menu {
  const _$_Menu();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.menu()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.menu'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Menu);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return menu();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return menu?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (menu != null) {
      return menu();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return menu(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return menu?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (menu != null) {
      return menu(this);
    }
    return orElse();
  }
}

abstract class _Menu implements StartGameState {
  const factory _Menu() = _$_Menu;
}

/// @nodoc
abstract class _$$_PlayCopyWith<$Res> {
  factory _$$_PlayCopyWith(_$_Play value, $Res Function(_$_Play) then) =
      __$$_PlayCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PlayCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$_Play>
    implements _$$_PlayCopyWith<$Res> {
  __$$_PlayCopyWithImpl(_$_Play _value, $Res Function(_$_Play) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Play with DiagnosticableTreeMixin implements _Play {
  const _$_Play();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.play()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.play'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Play);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return play();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return play?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (play != null) {
      return play();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return play(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return play?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (play != null) {
      return play(this);
    }
    return orElse();
  }
}

abstract class _Play implements StartGameState {
  const factory _Play() = _$_Play;
}

/// @nodoc
abstract class _$$_SoundCopyWith<$Res> {
  factory _$$_SoundCopyWith(_$_Sound value, $Res Function(_$_Sound) then) =
      __$$_SoundCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SoundCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$_Sound>
    implements _$$_SoundCopyWith<$Res> {
  __$$_SoundCopyWithImpl(_$_Sound _value, $Res Function(_$_Sound) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Sound with DiagnosticableTreeMixin implements _Sound {
  const _$_Sound();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.sound()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.sound'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Sound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return sound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return sound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (sound != null) {
      return sound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return sound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return sound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (sound != null) {
      return sound(this);
    }
    return orElse();
  }
}

abstract class _Sound implements StartGameState {
  const factory _Sound() = _$_Sound;
}

/// @nodoc
abstract class _$$_LanguageCopyWith<$Res> {
  factory _$$_LanguageCopyWith(
          _$_Language value, $Res Function(_$_Language) then) =
      __$$_LanguageCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LanguageCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$_Language>
    implements _$$_LanguageCopyWith<$Res> {
  __$$_LanguageCopyWithImpl(
      _$_Language _value, $Res Function(_$_Language) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Language with DiagnosticableTreeMixin implements _Language {
  const _$_Language();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.language()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.language'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Language);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return language();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return language?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (language != null) {
      return language();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return language(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return language?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (language != null) {
      return language(this);
    }
    return orElse();
  }
}

abstract class _Language implements StartGameState {
  const factory _Language() = _$_Language;
}

/// @nodoc
abstract class _$$_HowToPlayCopyWith<$Res> {
  factory _$$_HowToPlayCopyWith(
          _$_HowToPlay value, $Res Function(_$_HowToPlay) then) =
      __$$_HowToPlayCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_HowToPlayCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$_HowToPlay>
    implements _$$_HowToPlayCopyWith<$Res> {
  __$$_HowToPlayCopyWithImpl(
      _$_HowToPlay _value, $Res Function(_$_HowToPlay) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_HowToPlay with DiagnosticableTreeMixin implements _HowToPlay {
  const _$_HowToPlay();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.howToPlay()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.howToPlay'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_HowToPlay);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return howToPlay();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return howToPlay?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (howToPlay != null) {
      return howToPlay();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return howToPlay(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return howToPlay?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (howToPlay != null) {
      return howToPlay(this);
    }
    return orElse();
  }
}

abstract class _HowToPlay implements StartGameState {
  const factory _HowToPlay() = _$_HowToPlay;
}

/// @nodoc
abstract class _$$_AboutCopyWith<$Res> {
  factory _$$_AboutCopyWith(_$_About value, $Res Function(_$_About) then) =
      __$$_AboutCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AboutCopyWithImpl<$Res>
    extends _$StartGameStateCopyWithImpl<$Res, _$_About>
    implements _$$_AboutCopyWith<$Res> {
  __$$_AboutCopyWithImpl(_$_About _value, $Res Function(_$_About) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_About with DiagnosticableTreeMixin implements _About {
  const _$_About();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StartGameState.about()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'StartGameState.about'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_About);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() menu,
    required TResult Function() play,
    required TResult Function() sound,
    required TResult Function() language,
    required TResult Function() howToPlay,
    required TResult Function() about,
  }) {
    return about();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? menu,
    TResult? Function()? play,
    TResult? Function()? sound,
    TResult? Function()? language,
    TResult? Function()? howToPlay,
    TResult? Function()? about,
  }) {
    return about?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? menu,
    TResult Function()? play,
    TResult Function()? sound,
    TResult Function()? language,
    TResult Function()? howToPlay,
    TResult Function()? about,
    required TResult orElse(),
  }) {
    if (about != null) {
      return about();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Menu value) menu,
    required TResult Function(_Play value) play,
    required TResult Function(_Sound value) sound,
    required TResult Function(_Language value) language,
    required TResult Function(_HowToPlay value) howToPlay,
    required TResult Function(_About value) about,
  }) {
    return about(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Menu value)? menu,
    TResult? Function(_Play value)? play,
    TResult? Function(_Sound value)? sound,
    TResult? Function(_Language value)? language,
    TResult? Function(_HowToPlay value)? howToPlay,
    TResult? Function(_About value)? about,
  }) {
    return about?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Menu value)? menu,
    TResult Function(_Play value)? play,
    TResult Function(_Sound value)? sound,
    TResult Function(_Language value)? language,
    TResult Function(_HowToPlay value)? howToPlay,
    TResult Function(_About value)? about,
    required TResult orElse(),
  }) {
    if (about != null) {
      return about(this);
    }
    return orElse();
  }
}

abstract class _About implements StartGameState {
  const factory _About() = _$_About;
}
